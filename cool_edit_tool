tool_use_id=toolu_01LG6RwxAL55QdXiUjmzmQUb
tool_name=replace_code
input={"old_str": "I'll create a comprehensive Plant Care Dashboard that implements all the core features from your document:", "new_str": "I'll create a comprehensive Flask backend for the Plant Care Dashboard. Here's the complete backend implementation:\n\n## Flask Backend Structure\n\n```\nbackend/\n├── app.py                 # Main Flask application\n├── config.py             # Configuration settings\n├── models.py             # Database models\n├── requirements.txt      # Python dependencies\n├── .env                  # Environment variables (not included in version control)\n├── routes/\n│   ├── __init__.py\n│   ├── auth.py          # Authentication routes\n│   ├── gardens.py       # Garden management routes\n│   ├── data.py          # Data management routes\n│   └── weather.py       # Weather API routes\n├── utils/\n│   ├── __init__.py\n│   ├── csv_handler.py   # CSV import/export logic\n│   ├── simulation.py    # Plant data simulation\n│   ├── analytics.py     # Predictive analytics\n│   └── weather_api.py   # Weather API integration\n└── static/\n    └── index.html       # Frontend HTML file\n```\n\n## Main Application (app.py)\n\n```python\nfrom flask import Flask, render_template, send_from_directory\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom flask_cors import CORS\nfrom datetime import datetime\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\n# Initialize Flask app\napp = Flask(__name__, static_folder='static', static_url_path='')\n\n# Configuration\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'your_super_secret_development_key_change_in_production')\napp.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///plant_care.db')\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\n# Initialize extensions\ndb = SQLAlchemy(app)\nlogin_manager = LoginManager()\nlogin_manager.init_app(app)\nlogin_manager.login_view = 'auth.login'\nCORS(app, supports_credentials=True)\n\n# Import models\nfrom models import User, Garden, PlantReading\n\n# User loader for Flask-Login\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n\n# Import and register blueprints\nfrom routes.auth import auth_bp\nfrom routes.gardens import gardens_bp\nfrom routes.data import data_bp\nfrom routes.weather import weather_bp\n\napp.register_blueprint(auth_bp, url_prefix='/api')\napp.register_blueprint(gardens_bp, url_prefix='/api')\napp.register_blueprint(data_bp, url_prefix='/api')\napp.register_blueprint(weather_bp, url_prefix='/api')\n\n# Serve frontend\n@app.route('/')\ndef index():\n    return send_from_directory(app.static_folder, 'index.html')\n\n# Error handlers\n@app.errorhandler(404)\ndef not_found(error):\n    return {'error': 'Not found'}, 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    db.session.rollback()\n    return {'error': 'Internal server error'}, 500\n\n# Create database tables\nwith app.app_context():\n    db.create_all()\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=5000)\n```\n\n## Database Models (models.py)\n\n```python\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import UserMixin\nfrom datetime import datetime\nfrom app import db\n\nclass User(UserMixin, db.Model):\n    __tablename__ = 'users'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    password = db.Column(db.String(120), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_login = db.Column(db.DateTime, default=datetime.utcnow)\n    last_active_garden_id = db.Column(db.Integer, db.ForeignKey('gardens.id'), nullable=True)\n    \n    # Preferences\n    simulation_frequency = db.Column(db.Integer, default=60)  # seconds\n    moisture_threshold = db.Column(db.Integer, default=30)  # percentage\n    temperature_min = db.Column(db.Float, default=15.0)  # celsius\n    temperature_max = db.Column(db.Float, default=30.0)  # celsius\n    light_min = db.Column(db.Integer, default=200)  # lux\n    \n    # Relationships\n    gardens = db.relationship('Garden', backref='owner', lazy=True, cascade='all, delete-orphan')\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'username': self.username,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'last_login': self.last_login.isoformat() if self.last_login else None,\n            'preferences': {\n                'simulation_frequency': self.simulation_frequency,\n                'moisture_threshold': self.moisture_threshold,\n                'temperature_min': self.temperature_min,\n                'temperature_max': self.temperature_max,\n                'light_min': self.light_min\n            }\n        }\n\nclass Garden(db.Model):\n    __tablename__ = 'gardens'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)\n    name = db.Column(db.String(100), nullable=False)\n    location = db.Column(db.String(200), nullable=True)\n    location_lat = db.Column(db.Float, nullable=True)\n    location_lon = db.Column(db.Float, nullable=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_accessed = db.Column(db.DateTime, default=datetime.utcnow)\n    sensor_type = db.Column(db.String(50), default='simulated_basic')\n    \n    # Garden-specific settings\n    plant_type = db.Column(db.String(100), default='General')\n    watering_frequency = db.Column(db.Integer, default=3)  # days\n    \n    # Relationships\n    readings = db.relationship('PlantReading', backref='garden_obj', lazy=True, cascade='all, delete-orphan')\n    \n    def __repr__(self):\n        return f'<Garden {self.name}>'\n    \n    def to_dict(self):\n        latest_reading = PlantReading.query.filter_by(garden_id=self.id).order_by(PlantReading.timestamp.desc()).first()\n        return {\n            'id': self.id,\n            'name': self.name,\n            'location': self.location,\n            'location_lat': self.location_lat,\n            'location_lon': self.location_lon,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'last_accessed': self.last_accessed.isoformat() if self.last_accessed else None,\n            'sensor_type': self.sensor_type,\n            'plant_type': self.plant_type,\n            'watering_frequency': self.watering_frequency,\n            'latest_reading': latest_reading.to_dict() if latest_reading else None,\n            'readings_count': len(self.readings)\n        }\n\nclass PlantReading(db.Model):\n    __tablename__ = 'plant_readings'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    garden_id = db.Column(db.Integer, db.ForeignKey('gardens.id'), nullable=False)\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n    moisture_level = db.Column(db.Float, nullable=False)  # percentage\n    temperature = db.Column(db.Float, nullable=False)  # celsius\n    light_intensity = db.Column(db.Float, nullable=False)  # lux\n    humidity = db.Column(db.Float, nullable=True)  # percentage\n    ph_level = db.Column(db.Float, nullable=True)  # pH\n    notes = db.Column(db.Text, nullable=True)\n    is_manual = db.Column(db.Boolean, default=False)\n    \n    def __repr__(self):\n        return f'<Reading {self.timestamp} for Garden {self.garden_id}>'\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'garden_id': self.garden_id,\n            'timestamp': self.timestamp.isoformat() if self.timestamp else None,\n            'moisture_level': self.moisture_level,\n            'temperature': self.temperature,\n            'light_intensity': self.light_intensity,\n            'humidity': self.humidity,\n            'ph_level': self.ph_level,\n            'notes': self.notes,\n            'is_manual': self.is_manual\n        }\n```\n\n## Authentication Routes (routes/auth.py)\n\n```python\nfrom flask import Blueprint, request, jsonify\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom datetime import datetime\nfrom models import User, db\n\nauth_bp = Blueprint('auth', __name__)\n\n@auth_bp.route('/register', methods=['POST'])\ndef register():\n    try:\n        data = request.get_json()\n        \n        # Validation\n        if not data or not data.get('username') or not data.get('password'):\n            return jsonify({'error': 'Username and password are required'}), 400\n        \n        username = data['username'].strip()\n        password = data['password']\n        \n        if len(username) < 3:\n            return jsonify({'error': 'Username must be at least 3 characters long'}), 400\n        \n        if len(password) < 6:\n            return jsonify({'error': 'Password must be at least 6 characters long'}), 400\n        \n        # Check if user already exists\n        if User.query.filter_by(username=username).first():\n            return jsonify({'error': 'Username already exists'}), 409\n        \n        # Create new user\n        hashed_password = generate_password_hash(password)\n        new_user = User(\n            username=username,\n            password=hashed_password,\n            created_at=datetime.utcnow()\n        )\n        \n        db.session.add(new_user)\n        db.session.commit()\n        \n        return jsonify({\n            'message': 'User registered successfully',\n            'user': new_user.to_dict()\n        }), 201\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Registration failed'}), 500\n\n@auth_bp.route('/login', methods=['POST'])\ndef login():\n    try:\n        data = request.get_json()\n        \n        if not data or not data.get('username') or not data.get('password'):\n            return jsonify({'error': 'Username and password are required'}), 400\n        \n        username = data['username'].strip()\n        password = data['password']\n        \n        user = User.query.filter_by(username=username).first()\n        \n        if user and check_password_hash(user.password, password):\n            login_user(user, remember=True)\n            user.last_login = datetime.utcnow()\n            db.session.commit()\n            \n            return jsonify({\n                'message': 'Logged in successfully',\n                'user': user.to_dict()\n            }), 200\n        else:\n            return jsonify({'error': 'Invalid username or password'}), 401\n            \n    except Exception as e:\n        return jsonify({'error': 'Login failed'}), 500\n\n@auth_bp.route('/logout', methods=['POST'])\n@login_required\ndef logout():\n    logout_user()\n    return jsonify({'message': 'Logged out successfully'}), 200\n\n@auth_bp.route('/status', methods=['GET'])\ndef status():\n    if current_user.is_authenticated:\n        return jsonify({\n            'is_authenticated': True,\n            'user': current_user.to_dict()\n        }), 200\n    else:\n        return jsonify({'is_authenticated': False}), 200\n\n@auth_bp.route('/profile', methods=['GET', 'PUT'])\n@login_required\ndef profile():\n    if request.method == 'GET':\n        return jsonify({'user': current_user.to_dict()}), 200\n    \n    elif request.method == 'PUT':\n        try:\n            data = request.get_json()\n            \n            # Update preferences\n            if 'preferences' in data:\n                prefs = data['preferences']\n                if 'simulation_frequency' in prefs:\n                    current_user.simulation_frequency = prefs['simulation_frequency']\n                if 'moisture_threshold' in prefs:\n                    current_user.moisture_threshold = prefs['moisture_threshold']\n                if 'temperature_min' in prefs:\n                    current_user.temperature_min = prefs['temperature_min']\n                if 'temperature_max' in prefs:\n                    current_user.temperature_max = prefs['temperature_max']\n                if 'light_min' in prefs:\n                    current_user.light_min = prefs['light_min']\n            \n            # Update last active garden\n            if 'last_active_garden_id' in data:\n                current_user.last_active_garden_id = data['last_active_garden_id']\n            \n            db.session.commit()\n            return jsonify({'message': 'Profile updated successfully', 'user': current_user.to_dict()}), 200\n            \n        except Exception as e:\n            db.session.rollback()\n            return jsonify({'error': 'Failed to update profile'}), 500\n```\n\n## Garden Management Routes (routes/gardens.py)\n\n```python\nfrom flask import Blueprint, request, jsonify\nfrom flask_login import login_required, current_user\nfrom datetime import datetime\nfrom models import Garden, PlantReading, db\n\ngardens_bp = Blueprint('gardens', __name__)\n\n@gardens_bp.route('/gardens', methods=['GET'])\n@login_required\ndef get_gardens():\n    try:\n        gardens = Garden.query.filter_by(user_id=current_user.id).all()\n        return jsonify({\n            'gardens': [garden.to_dict() for garden in gardens]\n        }), 200\n    except Exception as e:\n        return jsonify({'error': 'Failed to fetch gardens'}), 500\n\n@gardens_bp.route('/gardens', methods=['POST'])\n@login_required\ndef add_garden():\n    try:\n        data = request.get_json()\n        \n        if not data or not data.get('name'):\n            return jsonify({'error': 'Garden name is required'}), 400\n        \n        new_garden = Garden(\n            user_id=current_user.id,\n            name=data['name'].strip(),\n            location=data.get('location', '').strip(),\n            location_lat=data.get('location_lat'),\n            location_lon=data.get('location_lon'),\n            sensor_type=data.get('sensor_type', 'simulated_basic'),\n            plant_type=data.get('plant_type', 'General'),\n            watering_frequency=data.get('watering_frequency', 3),\n            created_at=datetime.utcnow(),\n            last_accessed=datetime.utcnow()\n        )\n        \n        db.session.add(new_garden)\n        db.session.commit()\n        \n        return jsonify({\n            'message': 'Garden added successfully',\n            'garden': new_garden.to_dict()\n        }), 201\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to add garden'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>', methods=['GET'])\n@login_required\ndef get_garden(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        # Update last accessed\n        garden.last_accessed = datetime.utcnow()\n        db.session.commit()\n        \n        return jsonify({'garden': garden.to_dict()}), 200\n        \n    except Exception as e:\n        return jsonify({'error': 'Failed to fetch garden'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>', methods=['PUT'])\n@login_required\ndef update_garden(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        data = request.get_json()\n        \n        if 'name' in data:\n            garden.name = data['name'].strip()\n        if 'location' in data:\n            garden.location = data['location'].strip()\n        if 'location_lat' in data:\n            garden.location_lat = data['location_lat']\n        if 'location_lon' in data:\n            garden.location_lon = data['location_lon']\n        if 'sensor_type' in data:\n            garden.sensor_type = data['sensor_type']\n        if 'plant_type' in data:\n            garden.plant_type = data['plant_type']\n        if 'watering_frequency' in data:\n            garden.watering_frequency = data['watering_frequency']\n        \n        garden.last_accessed = datetime.utcnow()\n        db.session.commit()\n        \n        return jsonify({\n            'message': 'Garden updated successfully',\n            'garden': garden.to_dict()\n        }), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to update garden'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>', methods=['DELETE'])\n@login_required\ndef delete_garden(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        db.session.delete(garden)\n        db.session.commit()\n        \n        return jsonify({'message': 'Garden deleted successfully'}), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to delete garden'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>/readings', methods=['GET'])\n@login_required\ndef get_garden_readings(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        # Pagination\n        page = request.args.get('page', 1, type=int)\n        per_page = request.args.get('per_page', 100, type=int)\n        \n        readings = PlantReading.query.filter_by(garden_id=garden_id)\\\n                                   .order_by(PlantReading.timestamp.desc())\\\n                                   .paginate(page=page, per_page=per_page, error_out=False)\n        \n        return jsonify({\n            'readings': [reading.to_dict() for reading in readings.items],\n            'total': readings.total,\n            'pages': readings.pages,\n            'current_page': page\n        }), 200\n        \n    except Exception as e:\n        return jsonify({'error': 'Failed to fetch readings'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>/readings', methods=['POST'])\n@login_required\ndef add_reading(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        data = request.get_json()\n        \n        if not data:\n            return jsonify({'error': 'Reading data is required'}), 400\n        \n        # Validate required fields\n        required_fields = ['moisture_level', 'temperature', 'light_intensity']\n        for field in required_fields:\n            if field not in data:\n                return jsonify({'error': f'{field} is required'}), 400\n        \n        new_reading = PlantReading(\n            garden_id=garden_id,\n            moisture_level=float(data['moisture_level']),\n            temperature=float(data['temperature']),\n            light_intensity=float(data['light_intensity']),\n            humidity=float(data.get('humidity', 0)) if data.get('humidity') else None,\n            ph_level=float(data.get('ph_level', 0)) if data.get('ph_level') else None,\n            notes=data.get('notes', '').strip(),\n            is_manual=data.get('is_manual', True),\n            timestamp=datetime.utcnow()\n        )\n        \n        db.session.add(new_reading)\n        garden.last_accessed = datetime.utcnow()\n        db.session.commit()\n        \n        return jsonify({\n            'message': 'Reading added successfully',\n            'reading': new_reading.to_dict()\n        }), 201\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to add reading'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>/pair_sensor', methods=['POST'])\n@login_required\ndef pair_sensor(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        data = request.get_json()\n        sensor_type = data.get('sensor_type', 'simulated_basic')\n        \n        garden.sensor_type = sensor_type\n        garden.last_accessed = datetime.utcnow()\n        db.session.commit()\n        \n        return jsonify({\n            'message': f'Sensor type {sensor_type} paired with garden {garden_id}',\n            'garden': garden.to_dict()\n        }), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to pair sensor'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>/unpair_sensor', methods=['DELETE'])\n@login_required\ndef unpair_sensor(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        garden.sensor_type = 'none'\n        garden.last_accessed = datetime.utcnow()\n        db.session.commit()\n        \n        return jsonify({\n            'message': f'Sensor unpaired from garden {garden_id}',\n            'garden': garden.to_dict()\n        }), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to unpair sensor'}), 500\n\n@gardens_bp.route('/gardens/<int:garden_id>/sensors', methods=['GET'])\n@login_required\ndef list_sensors(garden_id):\n    try:\n        garden = Garden.query.filter_by(id=garden_id, user_id=current_user.id).first()\n        \n        if not garden:\n            return jsonify({'error': 'Garden not found'}), 404\n        \n        return jsonify({\n            'garden_id': garden.id,\n            'sensor_type': garden.sensor_type,\n            'available_sensors': [\n                'simulated_basic',\n                'simulated_full',\n                'moisture_only',\n                'full_environment',\n                'npk_sensor',\n                'none'\n            ]\n        }), 200\n        \n    except Exception as e:\n        return jsonify({'error': 'Failed to list sensors'}), 500\n```\n\nI'll continue with the rest of the backend in the next response..."}


